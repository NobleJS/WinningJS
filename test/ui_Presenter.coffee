"use strict";

jsdom = require("jsdom").jsdom
sandboxedModule = require("sandboxed-module")
Q = require("q")

window = jsdom(null, null, features: QuerySelector: true).createWindow()
$ = sandboxedModule.require("jquery-browserify", globals: { window })

WinJS = UI: {}, Resources: {}
ko = null

s = require("../lib/resources").s

Presenter = do ->
    globals =
        window: window
        document: window.document
        navigator: window.navigator
        WinJS: WinJS
        MSApp: execUnsafeLocalFunction: (f) -> f()
        Error: Error # necessary for `instanceof Error` checks :-/

    ko = sandboxedModule.require("knockoutify", globals: globals)

    utilsRequires =
        "../resources": require("../lib/resources")
        domify: sandboxedModule.require("domify", { globals })

    requires =
        knockoutify: ko
        "./utils": sandboxedModule.require("../lib/ui/utils", { globals, requires: utilsRequires })
        "jquery-browserify": $

    sandboxedModule.require("../lib/ui/Presenter", { globals, requires })

describe "Create UI presenter", ->
    beforeEach ->
        WinJS.UI.processAll = sinon.spy (el) ->
            if el.hasAttribute("data-win-control")
                el.winControl = {}
            for childControl in el.querySelectorAll("[data-win-control]")
                childControl.winControl = {}

            return Q.resolve()
        WinJS.UI.setOptions = sinon.spy()
        WinJS.Resources.processAll = sinon.spy()

    it "should result in the object having a `render` and `process` method", ->
        presenter = new Presenter(template: -> "<div></div>")
        expect(presenter).to.respondTo("render")
        expect(presenter).to.respondTo("process")

    describe "render", ->
        it "should result in an HTML element generated by executing the passed-in template", ->
            presenter = new Presenter(template: -> "<section><h1>Stuff</h1><p>text</p></section>")

            element = presenter.render()

            presenter.element.should.equal(element)
            element.tagName.should.equal("SECTION")
            $(element).find("h1").text().should.equal("Stuff")
            $(element).find("p").text().should.equal("text")

        it "should provide the template with the resources `s` util function", ->
            template = sinon.spy(-> "<p>Template markup</p>");
            presenter = new Presenter(template: template)

            presenter.render()

            template.should.have.been.calledWith(s: s)

        it "works even if an option called hasOwnProperty is passed", ->
            presenter = new Presenter(hasOwnProperty: 5, template: -> "<p>Hi</p>")

            presenter.render()

        describe "with viewModel", ->
            beforeEach -> sinon.spy(ko, "applyBindings")
            afterEach -> ko.applyBindings.restore()

            it "should apply Knockout bindings", ->
                viewModel = name: "My name"
                presenter = new Presenter(
                    template: -> """<div><p data-bind="text: name"></p></div>"""
                    viewModel: viewModel
                )

                element = presenter.render()
                ko.applyBindings.should.have.been.calledWith(viewModel, element)

        describe "with renderables", ->
            it "should render them", ->
                renderableA =
                    render: -> $("<p>Renderable A</p>")[0]
                renderableB =
                    render: -> $("<footer>Renderable B</footer>")[0]

                presenter = new Presenter(
                    template: -> """
                                    <section>
                                        <div class="class"></div>
                                        <div data-winning-region="foo"></div>
                                        <div data-winning-region="bar"></div>
                                    </section>
                                """
                    renderables:
                        foo: renderableA
                        bar: renderableB
                )

                element = presenter.render()

                element.tagName.should.equal("SECTION")
                $(element).find("div").hasClass("class").should.be.true
                $(element).find("region").length.should.equal(0)
                $(element).find("p").length.should.equal(1)
                $(element).find("p").text().should.equal("Renderable A")
                $(element).find("footer").length.should.equal(1)
                $(element).find("footer").text().should.equal("Renderable B")

            describe "when a region name that doesn't exist in the markup is specified", ->
                it "should reject with a decipherable error", ->
                    presenter = new Presenter(
                        template: -> """<section><div data-winning-region="foo"></div></section>"""
                        renderables:
                            baz: render: -> $("<strong>text</strong>")[0]
                    )

                    expect(presenter.render).to.throw('region "baz"')

            describe "that contain Knockout bindings", ->
                # Nested bindings should not be applied to the presenter element.
                beforeEach ->
                    sinon.stub(ko, "applyBindings", (viewModel, element) =>
                        if (element.querySelector("strong.sub[data-bind]"))
                            throw new Error("Unable to parse bindings.")
                    )
                afterEach ->
                    ko.applyBindings.restore()

                it "should apply bindings to the renderable's element only", ->
                    viewModel = title: "Composite Component"
                    presenter = new Presenter(
                        template: -> """
                                     <section>
                                        <h1 data-bind="text: title"></h1>
                                        <div data-winning-region="foo"></div>
                                     </section>
                                     """
                        renderables:
                            foo: render: -> $("""<strong class="sub" data-bind="text: message">Strong!</strong>""")[0]
                        viewModel: viewModel
                    )

                    presenter.render()
                    ko.applyBindings.should.not.throw

    describe "refresh", ->
        beforeEach ->
            iteration = 0
            @presenter = new Presenter(
                template: -> '<div><span data-bind="text: foo" data-iteration="' + iteration++ + '"></span></div>',
                viewModel: { foo: "FOO" }
            )

            @doIt = => @presenter.refresh({ foo: "FOO2" })

        describe "when the presenter has been `render`ed", ->
            beforeEach -> @presenter.render()

            describe "and added to the DOM already", ->
                beforeEach -> window.document.body.appendChild(@presenter.element)

                it "should be fulfilled with the new element", ->
                    oldElement = @presenter.element

                    @doIt().then (newElement) =>
                        newElement.should.equal(@presenter.element)
                        newElement.should.not.equal(oldElement)

                it "should re-render and re-bind the view model", ->
                    @doIt().then =>
                        @presenter.element.querySelector("span").getAttribute("data-iteration").should.equal("1")
                        @presenter.element.querySelector("span").textContent.should.equal("FOO2")

                it "should re-process the element", ->
                    @doIt().then =>
                        WinJS.UI.processAll.should.have.been.calledWith(@presenter.element)

                it "should replace the old element in the DOM with the newly refreshed one", ->
                    oldElement = @presenter.element
                    @doIt().then =>
                        expect($(window.document.body).find(@presenter.element).length).to.equal(1)
                        expect($(window.document.body).find(oldElement).length).to.equal(0)

            # TODO fix domify so that this works
            describe.skip "but not added to the DOM", ->
                it "should reject with an informative error message", ->
                    @doIt().should.be.rejected.with(/in the DOM/i)

        describe "when the presenter has never been `render`ed", ->
            it "should reject with an informative error message", ->
                @doIt().should.be.rejected.with(/in the DOM/i)


    describe "process", ->
        it "should call `WinJS.Resources.processAll` on the resulting element", ->
            presenter = new Presenter(template: -> "<p>Hi</p>")

            element = presenter.render()
            presenter.process().then (element) ->
                WinJS.Resources.processAll.should.have.been.calledWith(element)

        it "should call `WinJS.UI.processAll` on the resulting element", ->
            presenter = new Presenter(template: -> "<p>Hi</p>")

            presenter.render()
            presenter.process().then (element) ->
                WinJS.UI.processAll.should.have.been.calledWith(element)

        it "should set options on the root winControl with :scope", ->
            presenter = new Presenter(
                template: -> """<div data-win-control="WinJS.UI.ListView"></div>"""
                winControls:
                    ":scope":
                        foo: "bar"
                        baz: "quux"
            )

            presenter.render()
            presenter.process().then (element) ->
                WinJS.UI.processAll.should.have.been.calledWith(element)
                WinJS.UI.setOptions.should.have.been.calledWith(element.winControl, { foo: "bar", baz: "quux" })

        it "should set options on children winControls corresponding to their selectors", ->
            presenter = new Presenter(
                template: -> """
                                <div>
                                    <div class="a" data-win-control="WinJS.UI.ListView"></div>
                                    <div id="b" data-win-control="WinJS.UI.DatePicker"></div>
                                </div>
                            """
                winControls:
                    ".a": foo: "bar"
                    "#b": baz: "quux"
            )

            presenter.render()
            presenter.process().then (element) ->
                WinJS.UI.processAll.should.have.been.calledWith(element)
                WinJS.UI.setOptions.should.have.been.calledWith(element.querySelector(".a").winControl, { foo: "bar" })
                WinJS.UI.setOptions.should.have.been.calledWith(element.querySelector("#b").winControl, { baz: "quux" })

    describe "use", ->
        it "should, upon `render`ing, call process on the plugin object passing in the root element", ->
            myPlugin = process: sinon.stub().returns(Q.resolve())
            presenter = new Presenter(template: -> "<section></section>")

            presenter.use(myPlugin)
            presenter.render()

            myPlugin.process.should.have.been.calledWith(presenter.element)
