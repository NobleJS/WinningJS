"use strict";

jsdom = require("jsdom").jsdom
sandboxedModule = require("sandboxed-module")
Q = require("q")

window = jsdom(null, null, features: QuerySelector: true).createWindow()
$ = sandboxedModule.require("jquery-browserify", globals: { window })

WinJS = UI: {}, Resources: {}
ko = {}

s = require("../lib/resources").s

Presenter = do ->
    globals =
        window: window
        document: window.document
        WinJS: WinJS
        MSApp: execUnsafeLocalFunction: (f) -> f()
        Error: Error # necessary for `instanceof Error` checks :-/
    utilsRequires =
        "../resources": require("../lib/resources")
        domify: sandboxedModule.require("domify/lib/domify", { globals })
    requires =
        knockoutify: ko
        "./utils": sandboxedModule.require("../lib/ui/utils", { globals, requires: utilsRequires })
        "jquery-browserify": $

    sandboxedModule.require("../lib/ui/Presenter", { globals, requires })

describe "Create UI presenter", ->
    beforeEach ->
        WinJS.UI.processAll = sinon.spy (el) ->
            if el.hasAttribute("data-win-control")
                el.winControl = {}
            for childControl in el.querySelectorAll("[data-win-control]")
                childControl.winControl = {}

            return Q.resolve()
        WinJS.UI.setOptions = sinon.spy()
        WinJS.Resources.processAll = sinon.spy()
        ko.applyBindings = sinon.spy()

    it "should result in the object having a `render` and `process` method", ->
        presenter = new Presenter(template: -> "<div></div>")
        expect(presenter).to.respondTo("render")
        expect(presenter).to.respondTo("process")

    it "should result in the object having an `element` promise property", ->
        presenter = new Presenter(template: -> "<div></div>")
        expect(presenter).to.have.property("element")
        Q.isPromise(presenter.element).should.be.ok

    it "should provide the template with the resources `s` util function", ->
        template = sinon.spy(-> "<p>Template markup</p>");
        presenter = new Presenter(template: template)
        template.should.have.been.calledWith(s: s)

    describe "render", ->
        it "should result in an HTML element generated by executing the passed-in template", ->
            presenter = new Presenter(template: -> "<section><h1>Stuff</h1><p>text</p></section>")

            element = presenter.render()

            element.tagName.should.equal("SECTION")
            $(element).find("h1").text().should.equal("Stuff")
            $(element).find("p").text().should.equal("text")

        it "works even if an option called hasOwnProperty is passed", ->
            presenter = new Presenter(hasOwnProperty: 5, template: -> "<p>Hi</p>")

            presenter.render()

        describe "with viewModel", ->
            it "should apply Knockout bindings", ->
                viewModel = name: "My name"
                presenter = new Presenter(
                    template: -> """<div><p data-bind="text: name"></p></div>"""
                    viewModel: viewModel
                )

                element = presenter.render()
                ko.applyBindings.should.have.been.calledWith(viewModel, element)

        describe "with renderables", ->
            it "should render them", ->
                renderableA =
                    render: -> $("<p>Renderable A</p>")[0]
                renderableB =
                    render: -> $("<footer>Renderable B</footer>")[0]

                presenter = new Presenter(
                    template: -> """
                                    <section>
                                        <div class="class"></div>
                                        <div data-winning-region="foo"></div>
                                        <div data-winning-region="bar"></div>
                                    </section>
                                """
                    renderables:
                        foo: renderableA
                        bar: renderableB
                )

                element = presenter.render()

                element.tagName.should.equal("SECTION")
                $(element).find("div").hasClass("class").should.be.true
                $(element).find("region").length.should.equal(0)
                $(element).find("p").length.should.equal(1)
                $(element).find("p").text().should.equal("Renderable A")
                $(element).find("footer").length.should.equal(1)
                $(element).find("footer").text().should.equal("Renderable B")

            describe "when a region name that doesn't exist in the markup is specified", ->
                it "should reject with a decipherable error", ->
                    presenter = new Presenter(
                        template: -> """<section><div data-winning-region="foo"></div></section>"""
                        renderables:
                            baz: render: -> $("<strong>text</strong>")[0]
                    )

                    expect(presenter.render).to.throw('region "baz"')

            describe "that contain Knockout bindings", ->
                # Nested bindings should not be applied to the presenter element.
                beforeEach ->
                    ko.applyBindings = sinon.spy (viewModel, element) ->
                        if (element.querySelector("strong.sub[data-bind]"))
                            throw new Error("Unable to parse bindings.")

                it "should apply bindings to the renderable's element only", ->
                    viewModel = title: "Composite Component"
                    presenter = new Presenter(
                        template: -> """
                                     <section>
                                        <h1 data-bind="text: title"></h1>
                                        <div data-winning-region="foo"></div>
                                     </section>
                                     """
                        renderables:
                            foo: render: -> $("""<strong class="sub" data-bind="text: message">Strong!</strong>""")[0]
                        viewModel: viewModel
                    )

                    presenter.render()
                    ko.applyBindings.should.not.throw

    describe "process", ->
        it "should call `WinJS.Resources.processAll` on the resulting element", ->
            presenter = new Presenter(template: -> "<p>Hi</p>")

            element = presenter.render()
            presenter.process().then (element) ->
                WinJS.Resources.processAll.should.have.been.calledWith(element)

        it "should call `WinJS.UI.processAll` on the resulting element", ->
            presenter = new Presenter(template: -> "<p>Hi</p>")

            presenter.render()
            presenter.process().then (element) ->
                WinJS.UI.processAll.should.have.been.calledWith(element)

        it "should set options on the root winControl with :scope", ->
            presenter = new Presenter(
                template: -> """<div data-win-control="WinJS.UI.ListView"></div>"""
                winControls:
                    ":scope":
                        foo: "bar"
                        baz: "quux"
            )

            presenter.render()
            presenter.process().then (element) ->
                WinJS.UI.processAll.should.have.been.calledWith(element)
                WinJS.UI.setOptions.should.have.been.calledWith(element.winControl, { foo: "bar", baz: "quux" })

        it "should set options on children winControls corresponding to their selectors", ->
            presenter = new Presenter(
                template: -> """
                                <div>
                                    <div class="a" data-win-control="WinJS.UI.ListView"></div>
                                    <div id="b" data-win-control="WinJS.UI.DatePicker"></div>
                                </div>
                            """
                winControls:
                    ".a": foo: "bar"
                    "#b": baz: "quux"
            )

            presenter.render()
            presenter.process().then (element) ->
                WinJS.UI.processAll.should.have.been.calledWith(element)
                WinJS.UI.setOptions.should.have.been.calledWith(element.querySelector(".a").winControl, { foo: "bar" })
                WinJS.UI.setOptions.should.have.been.calledWith(element.querySelector("#b").winControl, { baz: "quux" })

    describe "bindViewModel", ->
        it "should call `ko.applyBindings` after waiting for the element promise", ->
            presenter = new Presenter(template: -> "<p>Hi</p>")

            Q.isResolved(presenter.element).should.be.false

            newViewModel = {}
            promise = presenter.bindViewModel(newViewModel).then ->
                Q.isFulfilled(presenter.element).should.be.true
                ko.applyBindings.should.have.been.calledWith(newViewModel, presenter.element.valueOf())

            presenter.render() # Invoke render to fulfill `presenter.element` promise.
            return promise

    describe "element", ->
        it "should be equal to an HTML element generated by executing the passed-in template", ->
            presenter = new Presenter(template: -> "<section><h1>Stuff</h1><p>text</p></section>")

            promise = presenter.element.then (element) ->
                element.tagName.should.equal("SECTION")
                $(element).find("h1").text().should.equal("Stuff")
                $(element).find("p").text().should.equal("text")

            presenter.render() # Invoke render to fulfill `presenter.element` promise.
            return promise

    describe "use", ->
        it "should call process on the plugin object passing in the root element", ->
            myPlugin = process: sinon.stub().returns(Q.resolve())
            presenter = new Presenter(template: -> "<section></section>")

            presenter.use(myPlugin)

            promise = presenter.element.then (element) ->
                myPlugin.process.should.have.been.calledWith(element)

            presenter.render() # Invoke render to fulfill `presenter.element` promise.
            return promise
