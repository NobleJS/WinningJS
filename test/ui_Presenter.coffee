"use strict";

jsdom = require("jsdom").jsdom
sandboxedModule = require("sandboxed-module")
Q = require("q")

window = jsdom(null, null, features: QuerySelector: true).createWindow()
$ = sandboxedModule.require("jquery-browserify", globals: { window })

WinJS = UI: {}, Resources: {}
ko = {}

s = require("../lib/resources").s

Presenter = do ->
    globals =
        window: window
        document: window.document
        WinJS: WinJS
        Error: Error # necessary for `instanceof Error` checks :-/
    requires =
        knockoutify: ko
        "../resources": require("../lib/resources")

    sandboxedModule.require("../lib/ui/Presenter", globals: globals, requires: requires)

describe "Create UI presenter", ->
    beforeEach ->
        WinJS.UI.processAll = sinon.stub().returns(Q.resolve())
        WinJS.Resources.processAll = sinon.stub().returns(Q.resolve())
        ko.applyBindings = sinon.spy()

    it "should result in the object having a `process` method", ->
        presenter = new Presenter(template: -> "<div></div>")
        expect(presenter).to.respondTo("process")

    it "should result in the object having an `element` promise property", ->
        presenter = new Presenter(template: -> "<div></div>")
        expect(presenter).to.have.property("element")
        Q.isPromise(presenter.element).should.be.ok

    it "should result in the object having a `winControl` promise property", ->
        presenter = new Presenter(template: -> "<div></div>")
        expect(presenter).to.have.property("winControl")
        Q.isPromise(presenter.winControl).should.be.ok

    it "should provide the template with the resources `s` util function", ->
        template = sinon.spy(-> "<p>Template markup</p>");
        presenter = new Presenter(template: template)
        template.should.have.been.calledWith(s: s)

    describe "process", ->
        it "should result in an HTML element generated by executing the passed-in template", ->
            presenter = new Presenter(template: -> "<section><h1>Stuff</h1><p>text</p></section>")

            presenter.process().then (element) ->
                element.tagName.should.equal("SECTION")
                $(element).find("h1").text().should.equal("Stuff")
                $(element).find("p").text().should.equal("text")

        it "should call `WinJS.UI.processAll` on the resulting element", ->
            presenter = new Presenter(template: -> "<p>Hi</p>")

            presenter.process().then (element) ->
                WinJS.UI.processAll.should.have.been.calledWith(element)

        it "should call `WinJS.Resources.processAll` on the resulting element", ->
            presenter = new Presenter(template: -> "<p>Hi</p>")

            presenter.process().then (element) ->
                WinJS.Resources.processAll.should.have.been.calledWith(element)

        describe "when the template returns zero elements", ->
            it "should fail with an informative error", ->
                expect(-> new Presenter(template: -> ""))
                    .to.throw("Expected the template to render exactly one element.")

        describe "when the template returns more than one element", ->
            it "should fail with an informative error", ->
                expect(-> new Presenter(template: -> "<header></header><section></section>"))
                    .to.throw("Expected the template to render exactly one element.")

        describe "with viewModel", ->
            it "should apply Knockout bindings", ->
                viewModel = name: "My name"
                presenter = new Presenter(
                    template: -> """<div><p data-bind="text: name"></p></div>"""
                    viewModel: viewModel
                )

                presenter.process().then (element) ->
                    ko.applyBindings.should.have.been.calledWith(viewModel, element)

        describe "with renderables", ->
            describe "both async and sync", ->
                it "should render them", ->
                    renderableAsync =
                        render: -> Q.resolve($("<p>paragraph text</p>")[0])
                    renderableSync =
                        render: -> $("<strong>strong text</strong>")[0]


                    presenter = new Presenter(
                        template: -> """
                                     <section>
                                        <div class="class"></div>
                                        <div data-winning-region="foo"></div>
                                        <div data-winning-region="bar"></div>
                                    </section>
                                    """
                        renderables:
                            foo: renderableAsync
                            bar: renderableSync
                    )

                    presenter.process().then (element) ->
                        element.tagName.should.equal("SECTION")
                        $(element).find("div").hasClass("class").should.be.true
                        $(element).find("region").length.should.equal(0)
                        $(element).find("p").length.should.equal(1)
                        $(element).find("p").text().should.equal("paragraph text")
                        $(element).find("strong").length.should.equal(1)
                        $(element).find("strong").text().should.equal("strong text")

            describe "when a region name that doesn't exist in the markup is specified", ->
                it "should reject with a decipherable error", ->
                    presenter = new Presenter(
                        template: -> """<section><div data-winning-region="foo"></div></section>"""
                        renderables:
                            baz: render: -> $("<strong>text</strong>")[0]
                    )

                    presenter.process().should.be.rejected.with('region "baz"')

            describe "that contain Knockout bindings", ->
                # Nested bindings should not be applied to the presenter element.
                beforeEach ->
                    ko.applyBindings = sinon.spy (viewModel, element) ->
                        if (element.querySelector("strong.sub[data-bind]"))
                            throw new Error("Unable to parse bindings.")

                it "should apply bindings to the renderable's element only", ->
                    viewModel = title: "Composite Component"
                    presenter = new Presenter(
                        template: -> """
                                     <section>
                                        <h1 data-bind="text: title"></h1>
                                        <div data-winning-region="foo"></div>
                                     </section>
                                     """
                        renderables:
                            foo: render: -> $("""<strong class="sub" data-bind="text: message">Strong!</strong>""")[0]
                        viewModel: viewModel
                    )

                    presenter.process().then (element) ->
                        ko.applyBindings.should.not.throw

    describe "element", ->
        it "should be equal to an HTML element generated by executing the passed-in template", ->
            presenter = new Presenter(template: -> "<section><h1>Stuff</h1><p>text</p></section>")

            promise = presenter.element.then (element) ->
                element.tagName.should.equal("SECTION")
                $(element).find("h1").text().should.equal("Stuff")
                $(element).find("p").text().should.equal("text")

            presenter.process() # Invoke process to fulfill `presenter.element` promise.
            return promise

    describe "use", ->
        it "should call process on the plugin object passing in the root element", ->
            myPlugin = process: sinon.stub().returns(Q.resolve())
            presenter = new Presenter(template: -> "<section></section>")

            presenter.use(myPlugin)

            promise = presenter.element.then (element) ->
                myPlugin.process.should.have.been.calledWith(element)

            presenter.process() # Invoke process to fulfill `presenter.element` promise.
            return promise
